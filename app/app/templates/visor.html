<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizador de STL</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        #viewer {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>
<body class="flex h-screen">
    <div class="w-1/4 p-4 border-r">
        <div class="flex items-center p-3 m-2">
            <a href="javascript:history.go(-1)" class="flex items-center text-gray-500 hover:text-blue-600 transition duration-200">
                <svg class="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
                </svg>
                <span class="text-sm font-medium">Volver</span>
            </a>
        </div>
        <hr>
        <h3 class="text-sm font-medium text-gray-900 mb-2">Instrucciones del visor:</h3>
        <ul class="list-disc list-inside text-sm text-gray-600 space-y-1">
            <li>Dispone de un botón para parar o activar el autogiro</li>
            <li>Dispone de un botón para centrar completo el modelo en la pantalla</li>
            <li>Mueve el ratón con el botón pulsado sobre el objeto para girarlo</li>
            <li>Usa el scroll del ratón para acercar o alejar</li>
        </ul>
        <hr class="m-2">
        <button id="downloadButton" class="w-full bg-green-500 text-white p-2 rounded">Descargar STL</button>
    </div>

    <div class="w-3/4 p-4 relative flex items-center justify-center">
        <div id="viewer"></div>
        <div class="absolute top-0 right-0 m-2 space-x-2">
            <button id="rotateButton" class="bg-gray-200 p-2 rounded">
                <svg class="h-8 w-8 text-blue-500" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">  
                    <polyline points="1 4 1 10 7 10" />  
                    <polyline points="23 20 23 14 17 14" />  
                    <path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15" />
                </svg>
            </button>
            <button id="centerButton" class="bg-gray-200 p-2 rounded">
                <svg class="h-8 w-8 text-blue-500" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">  
                    <polyline points="5 9 2 12 5 15" />  
                    <polyline points="9 5 12 2 15 5" />  
                    <polyline points="15 19 12 22 9 19" />  
                    <polyline points="19 9 22 12 19 15" />  
                    <line x1="2" y1="12" x2="22" y2="12" />  
                    <line x1="12" y1="2" x2="12" y2="22" />
                </svg>
            </button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        let stl_file = '/static/stls/{{stl_name}}'
        let scene = new THREE.Scene();
        let camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        let renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setClearColor(0xadd8e6);
        
        const viewer = document.getElementById('viewer');
        renderer.setSize(viewer.clientWidth, viewer.clientHeight);
        viewer.appendChild(renderer.domElement);

        let ambientLight = new THREE.AmbientLight(0x404040, 2);
        scene.add(ambientLight);

        let directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        let controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.enableZoom = true;

        let currentMesh = null;
        let isRotating = true;

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            if (currentMesh && isRotating) {
                currentMesh.rotation.y += 0.01;
            }
            renderer.render(scene, camera);
        }
        animate();

        function loadSTL(url) {
            let loader = new THREE.STLLoader();
            loader.load(url, function (geometry) {
                let material = new THREE.MeshPhongMaterial({ color: 0xaaaaaa, specular: 0x111111, shininess: 100 });
                let mesh = new THREE.Mesh(geometry, material);
                
                while (scene.children.length > 2) {
                    scene.remove(scene.children[scene.children.length - 1]);
                }
                
                scene.add(mesh);
                currentMesh = mesh;
                fitToScreen();
            });
        }

        function fitToScreen() {
            if (currentMesh) {
                let boundingBox = new THREE.Box3().setFromObject(currentMesh);
                let size = boundingBox.getSize(new THREE.Vector3()).length();
                let center = boundingBox.getCenter(new THREE.Vector3());

                controls.target.copy(center);
                controls.update();

                camera.position.copy(center);
                camera.position.z += size * 1.5;
                camera.far = size * 5;
                camera.updateProjectionMatrix();
            }
        }

        document.getElementById('centerButton').addEventListener('click', fitToScreen);
        document.getElementById('rotateButton').addEventListener('click', () => {
            isRotating = !isRotating;
        });

        document.getElementById('downloadButton').addEventListener('click', () => {
            window.location.href = stl_file; // URL del STL generado
        });

        window.addEventListener('resize', function () {
            renderer.setSize(viewer.clientWidth, viewer.clientHeight);
            camera.aspect = viewer.clientWidth / viewer.clientHeight;
            camera.updateProjectionMatrix();
        });

        loadSTL(stl_file); // Cargar STL generado
    </script>
</body>
</html>
